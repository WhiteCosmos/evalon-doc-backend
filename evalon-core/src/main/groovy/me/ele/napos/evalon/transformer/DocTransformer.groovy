package me.ele.napos.evalon.transformerimport me.ele.napos.evalon.domain.JavaMethodDomainimport me.ele.napos.evalon.domain.JavaServiceDomainimport me.ele.napos.evalon.domain.fields.JavaFieldDomainimport me.ele.napos.evalon.domain.types.*import me.ele.napos.evalon.exceptions.DocRecurseExceptionimport me.ele.napos.evalon.structs.JavaFieldimport me.ele.napos.evalon.structs.JavaMethodimport me.ele.napos.evalon.structs.JavaServiceimport me.ele.napos.evalon.visitor.VisitorHelperimport org.springframework.stereotype.Component/** * Transform domain into doc */@Componentclass DocTransformer {    JavaMethod transformMethod(JavaMethodDomain methodDomain, boolean hasContent = true) {        JavaMethod javaMethod = new JavaMethod(                commentTitle: methodDomain.commentTitle,                commentBody: methodDomain.commentBody,                methodName: methodDomain.methodName,                restfulMethod: methodDomain.restfulMethod,                restfulUrl: methodDomain.restfulUrl,                isDeprecated: methodDomain.isDeprecated)        if (!hasContent) {            return javaMethod        }        methodDomain.parameters.each { fieldDomain ->            JavaField javaField = buildJavaFieldFrom(fieldDomain)            javaMethod.parameters.add(javaField)        }        if (!methodDomain.responses) {            javaMethod.response = null        } else {            def responseField = buildJavaFieldFrom(methodDomain.responses.first())            responseField && javaMethod.response << responseField        }        methodDomain.exceptions.each { exp ->            javaMethod.exceptions << new JavaField(                    fieldName: exp.simpleName,                    fieldType: exp.simpleName,                    fieldCommentTitle: exp.commentTitle)        }        if (javaMethod.parameters) {            javaMethod.parametersAsJson = transformToJson(javaMethod.parameters)        }        if (javaMethod.response) {            javaMethod.responseAsJson = javaMethod.response.first().toJsonStr(1)        }        return javaMethod    }    String transformToJson(List<JavaField> javaFields) {        def sb = new StringBuilder()        sb.append("{\n")        javaFields.each {            sb.append(it.toJsonStr(1))        }        sb.append("}\n")        return sb.toString()    }    List<JavaField> transformPojos(Collection<JavaPojoType> pojoTypes, boolean hasContent = true) {        List<JavaField> javaFields = []        if (hasContent) {            pojoTypes.each {                it && javaFields.add(buildJavaFieldFrom(it))            }        } else {            pojoTypes.each {                it && javaFields << new JavaField(                        fieldName: it.simpleName,                        fieldQualifyName: it.qualifiedName,                        fieldCommentTitle: it.commentTitle,                        fieldCommentBody: it.commentBody)            }        }        return javaFields.sort { it.fieldName }    }    List<JavaService> transform(Collection<JavaServiceDomain> serviceDomains, boolean hasContent = true) {        List<JavaService> classServices = []        serviceDomains.each { serviceDomain ->            if (!serviceDomain) {                return            }            JavaService classService = new JavaService(                    commentTitle: serviceDomain.commentTitle,                    serviceName: serviceDomain.serviceName,                    serviceQualifiedName: serviceDomain.serviceQualifiedName,                    serviceType: serviceDomain.serviceType,                    deprecated: serviceDomain.isDeprecated)            serviceDomain.methods.each { methodDomain ->                methodDomain.isDeprecated = serviceDomain.isDeprecated                methodDomain && classService.methods.add(transformMethod(methodDomain, hasContent))            }            classService.methods.each {                it.serviceName = classService.serviceName                it.serviceQualifiedName = classService.serviceQualifiedName            }            classService.methods.sort {                return it.methodName            }            classServices.add(classService)        }        classServices.sort {            return it.serviceName        }        return classServices    }    private JavaField buildJavaFieldFrom(JavaAbstractType fieldType, List<String> stack = []) {        JavaField javaField = new JavaField(                fieldName: fieldType.simpleName,                fieldType: fieldType.simpleName)        buildFromJavaPrimitiveType(javaField, fieldType)        buildFromJavaEnumType(javaField, fieldType)        buildFromJavaGenericType(javaField, fieldType, stack)        buildFromJavaPojoType(javaField, fieldType, stack)        buildFromJavaListType(javaField, fieldType, stack)        buildFromJavaMapType(javaField, fieldType, stack)        return javaField    }    private JavaField buildJavaFieldFrom(JavaFieldDomain fieldDomain,                                         List<String> stack = []) {        JavaField javaField = new JavaField()        if (!checkField(fieldDomain)) { // 补偿机制            javaField.fieldName = javaField.fieldName            javaField.fieldType = "Object"            return javaField        }        javaField.fieldName = fieldDomain.fieldName        javaField.fieldType = getFieldTypeName(fieldDomain)        javaField.fieldCommentTitle = fieldDomain.fieldCommentTitle        javaField.fieldCommentTitle = fieldDomain.fieldCommentTitle        javaField.isRequired = fieldDomain.isRequired        if (!fieldDomain.fieldTypes) {            return javaField        }        def fieldType = fieldDomain.fieldTypes.first()        buildFromJavaPrimitiveType(javaField, fieldType)        buildFromJavaEnumType(javaField, fieldType)        buildFromJavaGenericType(javaField, fieldType, stack)        buildFromJavaPojoType(javaField, fieldType, stack)        buildFromJavaListType(javaField, fieldType, stack)        buildFromJavaMapType(javaField, fieldType, stack)        return javaField    }    private boolean checkField(JavaFieldDomain fieldDomain) {        if (!fieldDomain) {            return false        }        if (!fieldDomain.fieldTypes) {            return false        }        return true    }    private String getFieldTypeName(JavaFieldDomain fieldDomain) {        if (!fieldDomain.fieldTypes) {            return fieldDomain.fieldTypeName        }        return fieldDomain.fieldTypes.first().getSimpleName()    }    void buildFromJavaPrimitiveType(JavaField javaField, JavaAbstractType fieldType) {        if (!fieldType.instanceOf(JavaPrimitiveType)) {            return        }        javaField.fieldType = fieldType.simpleName    }    void buildFromJavaEnumType(JavaField javaField, JavaAbstractType fieldType) {        if (!fieldType.instanceOf(JavaEnumType)) {            return        }        fieldType = (fieldType as JavaEnumType)        fieldType.values.each { v ->            JavaField f = new JavaField(fieldName: v.name,                    fieldType: "STRING",                    fieldEnumParent: fieldType.toString())            javaField.fields.add(f)        }        javaField.fieldCommentTitle = fieldType.commentTitle        javaField.fieldCommentBody = fieldType.commentBody    }    void buildFromJavaGenericType(JavaField javaField, JavaAbstractType fieldType, List<String> stack = []) {        if (!fieldType.instanceOf(JavaGenericType)) {            return        }        fieldType = (fieldType as JavaGenericType)        javaField.fieldType = fieldType.simpleName        if (fieldType.genericType) {            tagEvalonPojoTypeRecurse(fieldType.genericType) // 标记递归的POJO            tagEvalonPojoTypeCycle(fieldType.genericType, stack) // 标记循环依赖的POJO            JavaPojoType pojoType = fieldType.build() as JavaPojoType            javaField.fields << buildJavaFieldFrom(pojoType, stack)        }    }    void buildFromJavaPojoType(JavaField javaField, JavaAbstractType fieldType, List<String> stack = []) {        if (!fieldType.instanceOf(JavaPojoType)) {            return        }        fieldType = (fieldType as JavaPojoType)        javaField.fieldType = fieldType.simpleName        javaField.fieldQualifyName = fieldType.qualifiedName        javaField.fieldCommentTitle = fieldType.commentTitle        javaField.fieldCommentBody = fieldType.commentBody        stack.push(fieldType.qualifiedName)        buildFromEvalonPojoExtensions(javaField, fieldType, stack)        if (fieldType.isRecurse) {            javaField.isRecursion = true            return        }        if (fieldType.isCycle) {            javaField.isCycle = true            return        }        tagEvalonPojoTypeRecurse(fieldType) // 标记递归的POJO        tagEvalonPojoTypeCycle(fieldType, stack) // 标记循环依赖的POJO        fieldType.fields.each { fieldDomain ->            javaField.fields << buildJavaFieldFrom(fieldDomain, stack)            stack && stack.pop()        }        stack.clear()    }    Closure replaceToEmptyPojo = { JavaAbstractType t ->        JavaPojoType p = null        if (t.instanceOf(JavaGenericType)) {            t = t as JavaGenericType            p = t.genericType as JavaPojoType            //递归处理其它POJO            t.argumentTypes.each {                if (it.types) {                    VisitorHelper.replaceEvalonAbstractType(it.types.first(), replaceToEmptyPojo)                }            }        }        if (t.instanceOf(JavaPojoType)) {            p = t as JavaPojoType        }        if (!p || (!p.isRecurse && !p.isCycle)) {            return t        }        def empty = new JavaPojoType(                simpleName: p.simpleName,                qualifiedName: p.qualifiedName,                commentTitle: p.commentTitle,                packageName: p.packageName,                isRecurse: true,                imports: p.imports,                extensions: p.extensions)        if (t.instanceOf(JavaGenericType)) {            t.genericType = empty        }        if (t.instanceOf(JavaPojoType)) {            return empty        }        return t    }    void tagEvalonPojoTypeRecurse(JavaAbstractType fieldType) throws DocRecurseException {        if (!fieldType || !fieldType.instanceOf(JavaPojoType)) {            return        }        fieldType = (fieldType as JavaPojoType)        fieldType.fields.each { field ->            if (!field.fieldTypes) {                return            }            VisitorHelper.visitEvalonAbstractType(field.fieldTypes.first(), { JavaAbstractType evalonAbstractType ->                if (!evalonAbstractType || !evalonAbstractType.instanceOf(JavaPojoType)) {                    return evalonAbstractType                }                def p = (evalonAbstractType as JavaPojoType)                if (fieldType == p) {                    p.isRecurse = true                    VisitorHelper.replaceEvalonAbstractType(field.fieldTypes.first(), replaceToEmptyPojo)                }            })        }    }    void tagEvalonPojoTypeCycle(JavaAbstractType fieldType, List<String> stack = []) {        if (!fieldType || !fieldType.instanceOf(JavaPojoType)) {            return        }        fieldType = (fieldType as JavaPojoType)        fieldType.fields.each { field ->            if (!field.fieldTypes) {                return            }            VisitorHelper.visitEvalonAbstractType(field.fieldTypes.first(), { JavaAbstractType evalonAbstractType ->                if (!evalonAbstractType || !evalonAbstractType.instanceOf(JavaPojoType)) {                    return                }                def p = (evalonAbstractType as JavaPojoType)                if (p.qualifiedName in stack && !p.isRecurse) {                    p.isCycle = true                    VisitorHelper.replaceEvalonAbstractType(field.fieldTypes.first(), replaceToEmptyPojo)                }            })        }    }    void buildFromEvalonPojoExtensions(JavaField javaField, JavaPojoType fieldType, List<String> stack = []) {        if (!fieldType.extensions) {            return        }        Closure recurseExtensions        recurseExtensions = { List<JavaPojoType> types ->            types.each { type ->                type.fields.each { field ->                    if (!field) {                        return                    }                    if (javaField.fields.any {                        it && it.fieldName == field.fieldName                    }) {                        return                    }                    javaField.fields << buildJavaFieldFrom(field, stack)                }                recurseExtensions(type.extensions)            }        }        recurseExtensions(fieldType.extensions)    }    @SuppressWarnings("GroovyAssignabilityCheck")    void buildFromJavaListType(JavaField javaField, JavaAbstractType fieldType, List<String> stack = []) {        if (!fieldType.instanceOf(JavaListType)                && !fieldType.instanceOf(JavaSetType)) {            return        }        javaField.fields << buildJavaFieldFrom(fieldType.typeArgument.first(), stack)    }    void buildFromJavaMapType(JavaField javaField, JavaAbstractType fieldType, List<String> stack = []) {        if (!fieldType.instanceOf(JavaMapType)) {            return        }        fieldType = (fieldType as JavaMapType)        javaField.fields << buildJavaFieldFrom(fieldType.keyTypeArgument.first(), stack)        javaField.fields << buildJavaFieldFrom(fieldType.valueTypeArgument.first(), stack)    }}